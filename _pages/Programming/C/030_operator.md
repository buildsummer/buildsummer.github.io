{% raw %}
---
title: 연산자
date: 2025-02-02 183700
---
---
#  연산자

* 산술연산자 : + - * /
* 대입연산자 : =
* 복합 대입연산 : +=, -=, *=, /=
* 증감 연산자 : ++, 속도는 이게 제일 빨라서 +=는 ++로 알아서 변환됨
* <font color = 'ff8000'><b>sizeof</b></font>
  * sizeof는 연산자다. 함수가 아님.
  * sizeof int
  * sizeof(int)

---
# 산술변환

* 연산 시 자료형이 다를 경우 컴파일러가 더 큰 자료형으로 알아서 변경
  * 산술 변환 시 <font color = 'ff8000'><b>signed와 unsigned가 섞여있으면 예기치 못한 문제</b></font>를 발생시킬 수 있으므로 최대한 배제

---
# 비트연산자

* 비트(이진법 한자리) 하나하나에 대해 연산을 수행
  * & (AND) : 둘다 1이어야 1
  * \| (OR) : 둘 중 하나만 1이어도 1
  * ^ (XOR) : 서로 다르면 1
  * \<\< (Shift) : \<\< 방향으로 x만큼 이동, 빈자리는 0으로 채움
  * \>\> (Shift) : \>\> 방향으로 x만큼 이동, 빈자리는 맨 앞의 수가 반복(환경에 따라 무조건 0일 수도 있음)
  * \~ (반전) : 0을 1로, 1을 0으로 변경
    * 빈공간이라서 0으로 표기된 메모리 공간까지 반전시킴

```c
int main() {
    int aa = 10, b = 1;
    double bb = 3;
    printf("int / double = double : %f \n", aa / bb); // 산술변환
    printf("pure b : %d \n", b);
    printf("b += 1 : %d \n", b += 1);
    printf("b -= 1 : %d \n", b -= 1);
    printf("b *= 3 : %d \n", b *= 3);
    printf("b /= 3 : %d \n", b /= 3);
    printf("b++    : %d \n", b++);
    printf("++b    : %d \n", ++b);

    int a = 0xAF; // 10101111
    int b = 0xB5; // 10110101
    printf("%x \n", a & b);
    printf("%x \n", a | b);
    printf("%x \n", a ^ b);
    printf("%x \n", ~a);
    printf("%x \n", a << 2);
    printf("%x \n", b >> 3);
}
```
```text
int / double = double : 3.333333 
pure b : 1 
b += 1 : 2 
b -= 1 : 1 
b *= 3 : 3 
b /= 3 : 1 
b++    : 1 
++b    : 3 
a5 
bf 
1a 
ffffff50 
2bc 
16 
```

---
# 연산 우선순위

* 아래 모든 건 <font color = 'ff8000'><b>연산자</b></font>임에 유의하자
* 괄호가 최우선이므로 헷갈리면 괄호를 쓰자

|순위|연산자|순위 내 우선|
|:--:|------|----|
|1   |(), [], .|왼쪽|
|2   |!, ~, ++, --, 부호(+-), 포인터(*, &), sizeof, 캐스트|오른쪽|
|3   |*(곱셈), /, %|왼쪽|
|4   |+, -|왼쪽|
|5   |<<, >>|왼쪽|
|6   |<, <=, >, >=|왼쪽|
|7   |==, !=|왼쪽|
|8   |&|왼쪽|
|9   |^|왼쪽|
|10  |\||왼쪽|
|11  |&&|왼쪽|
|12  |\|\||왼쪽|
|13  |?, :|오른쪽|
|14  |=, 복합대입|오른쪽|
|15  |,|왼쪽|

* [] : 배열 포인터연산
* .  : 구조체 멤버 접근
* 캐스트 : (int), (char) ...
* & : 비트연산자



{% endraw %}
